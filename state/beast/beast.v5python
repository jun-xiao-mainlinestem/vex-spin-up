{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\nleftmotor1 = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nleftmotor2 = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)\nleftmotor3 = Motor(Ports.PORT12, GearSetting.RATIO_18_1, True)\nMotorGroupLeft = MotorGroup(leftmotor1, leftmotor2, leftmotor3)\nrightmotor1 = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nrightmotor2 = Motor(Ports.PORT19, GearSetting.RATIO_18_1, False)\nrightmotor3 = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nMotorGroupRight = MotorGroup(rightmotor1, rightmotor2, rightmotor3)\nroller = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\npneumatics = DigitalOut(brain.three_wire_port.a)\ninertial_2 = Inertial(Ports.PORT10)\ndistance_2 = Distance(Ports.PORT9)\ncontroller_1 = Controller(PRIMARY)\nantinova = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\n\ndrivetrainStop = False\n\nROLL_ANGLE = -120\nROLL_ANGLE_DOUBLE = 200\nROLL_DISTANCE = 7.5\nWALL_DISTANCE = 37\n\ndef when_started1():\n    pneumatics.set(False)\n    brain.screen.print(\"Calibrating!\")\n    while inertial_2.is_calibrating():\n       sleep(50)\n    controller_1.rumble(\"---\")\n\ndef driveFor_distance_speed(\n    driveFor_distance_speed__distance, driveFor_distance_speed__speed\n):\n    MotorGroupLeft.set_velocity(driveFor_distance_speed__speed, PERCENT)\n    MotorGroupRight.set_velocity(driveFor_distance_speed__speed, PERCENT)\n    d = driveFor_distance_speed__distance / 12.56\n    MotorGroupLeft.spin_for(FORWARD, -d, TURNS, wait=False)\n    MotorGroupRight.spin_for(FORWARD, -d, TURNS, wait=True)\n\ndef turnFor_degree_speed(turnFor_degree_speed__degree, turnFor_degree_speed__speed):\n    MotorGroupLeft.set_velocity(turnFor_degree_speed__speed, PERCENT)\n    MotorGroupRight.set_velocity(turnFor_degree_speed__speed, PERCENT)\n    d = turnFor_degree_speed__degree / 0.33\n    MotorGroupLeft.spin_for(REVERSE, d, DEGREES, wait=False)\n    MotorGroupRight.spin_for(REVERSE, (d * -1), DEGREES, wait=True)\n\ndef turnnorth():\n    if inertial_2.heading(DEGREES) <= 180:\n        turnFor_degree_speed(-inertial_2.heading(DEGREES), 50)\n    else:\n        turnFor_degree_speed(360 - inertial_2.heading(DEGREES), 50)\n\ndef turnsouth():\n    turnFor_degree_speed(180 - inertial_2.heading(DEGREES), 50)\n\ndef turneast():\n    if inertial_2.heading(DEGREES) > 270:\n        turnFor_degree_speed(360 + 90 - inertial_2.heading(DEGREES), 50)\n    else:\n        turnFor_degree_speed(90 - inertial_2.heading(DEGREES), 50)\n\ndef turnwest():\n    if inertial_2.heading(DEGREES) > 90:\n        turnFor_degree_speed(270 - inertial_2.heading(DEGREES), 50)\n    else:\n        turnFor_degree_speed(-(inertial_2.heading(DEGREES) + 90), 50)\n\ndef ondriver_drivercontrol_2():\n    global drivetrainStop\n    while True:\n        straight = -controller_1.axis3.position()\n        turn = controller_1.axis1.position() / -2\n        if straight == 0 and turn == 0:\n            if drivetrainStop:\n                MotorGroupLeft.stop()\n                MotorGroupRight.stop()\n                drivetrainStop = False\n        else:\n            MotorGroupLeft.set_velocity((straight + turn), PERCENT)\n            MotorGroupRight.set_velocity((straight - turn), PERCENT)\n            MotorGroupLeft.spin(FORWARD)\n            MotorGroupRight.spin(FORWARD)\n            drivetrainStop = True\n        wait(5, MSEC)\n\ndoit = True\ndef windshieldwiper():\n    global doit\n    if doit:\n        antinova.spin_for(FORWARD, 90, DEGREES, wait=False)\n        doit = False\n    else:\n        antinova.spin_for(REVERSE, 90, DEGREES, wait=False)\n        doit = True\n\ndef onevent_controller_1buttonB_pressed_0():\n    MotorGroupLeft.set_stopping(HOLD)\n    MotorGroupLeft.stop()\n    MotorGroupRight.set_stopping(HOLD)\n    MotorGroupRight.stop()\n\ndef roll():\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(FORWARD, ROLL_ANGLE_DOUBLE, DEGREES, wait=True)\n\ndef roll_reverse():\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE_DOUBLE, DEGREES, wait=True)\n\ndef drive_and_roll():\n    a = inertial_2.heading(DEGREES)\n    quad = 0\n    if a <= 45 or a > 360 - 45:\n        quad = 1\n    if a > 45 and a <= 90 + 45:\n        quad = 2\n    if a > 90 + 45 and a <= 180 + 45:\n        quad = 3\n    if a > 180 + 45 and a < 360 - 45:\n        quad = 4\n\n    if quad == 1:\n        turnnorth()\n    if quad == 2:\n        turneast()\n    if quad == 3:\n        turnsouth()\n    if quad == 4:\n        turnwest()\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 50)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(FORWARD, ROLL_ANGLE_DOUBLE, DEGREES, wait=True)\n    driveFor_distance_speed(-1, 50)\n\n\ndef shootString():\n    if (controller_1.buttonR1.pressing()):\n        pneumatics.set(True)\n\ndef test():\n    brain.timer.clear()\n    auton_started = True\n\n    controller_1.screen.clear_row(1)\n    controller_1.screen.set_cursor(1, 1)\n    controller_1.screen.print(brain.timer.time)\n\ndef far():\n    inertial_2.set_heading(0, DEGREES)\n    distancetodrive = distance_2.object_distance(INCHES) - WALL_DISTANCE\n    if distancetodrive > 20 or distancetodrive < 14:\n        distancetodrive = 17\n    driveFor_distance_speed(distancetodrive, 40)\n    turneast()\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 50)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n\n    driveFor_distance_speed(-4.5, 30)\n    turnnorth()\n    driveFor_distance_speed(-60, 30)\n\ndef far_disks():\n    inertial_2.set_heading(0, DEGREES)\n    distancetodrive = distance_2.object_distance(INCHES) - WALL_DISTANCE\n    if distancetodrive > 20 or distancetodrive < 14:\n        distancetodrive = 17\n    driveFor_distance_speed(distancetodrive, 50)\n    turneast()\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 50)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n\n    driveFor_distance_speed(-4, 50)\n    a = 135 + 90 - inertial_2.heading(DEGREES)\n\n    turnFor_degree_speed(a, 50)\n    driveFor_distance_speed(50, 50)\n    turneast()\n    distancetodrive = distance_2.object_distance(INCHES) - 14\n    driveFor_distance_speed(distancetodrive, 50)\n    turnsouth()\n    wait(0.5, SECONDS)\n    turnsouth()\n    driveFor_distance_speed(35, 70)\n    driveFor_distance_speed(-16, 70)\n\ndef far_no_gyro():\n    distancetodrive = distance_2.object_distance(INCHES) - WALL_DISTANCE\n    if distancetodrive > 20 or distancetodrive < 14:\n        distancetodrive = 17\n    driveFor_distance_speed(distancetodrive, 40)\n    turnFor_degree_speed(90, 50)\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 50)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n\n    driveFor_distance_speed(-4.5, 30)\n    turnFor_degree_speed(-90, 50)\n    driveFor_distance_speed(-60, 30)\n\ndef near_disks():\n    inertial_2.set_heading(180,DEGREES)\n    driveFor_distance_speed(1, 30)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n\n    driveFor_distance_speed(-8, 50)\n    a = inertial_2.heading(DEGREES)\n\n    turnFor_degree_speed(-(a - 45), 50)\n    driveFor_distance_speed(32, 50)\n\n    turnsouth()\n    wait(1, SECONDS)\n    turnsouth()\n    distancetodrive = distance_2.object_distance(INCHES) - 12\n    driveFor_distance_speed(distancetodrive, 50)\n    turneast()\n    wait(1, SECONDS)\n    turneast()\n    driveFor_distance_speed(45, 60)\n\ndef blockNear():\n    inertial_2.set_heading(180,DEGREES)\n    windshieldwiper()\n    driveFor_distance_speed(1, 30)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n\n    driveFor_distance_speed(-18, 60)\n    a = inertial_2.heading(DEGREES)\n\n    turnFor_degree_speed(-(a - 45), 50)\n    driveFor_distance_speed(35, 70)\n\n    wait(6, SECONDS)\n    turnsouth()\n    wait(0.5, SECONDS)\n    turnsouth()\n    distancetodrive = distance_2.object_distance(INCHES) - 12\n    driveFor_distance_speed(distancetodrive, 60)\n    turneast()\n    driveFor_distance_speed(40, 70)\n\ndef blockFar():\n    inertial_2.set_heading(0,DEGREES)\n    windshieldwiper()\n    distancetodrive = distance_2.object_distance(INCHES) - WALL_DISTANCE\n    if distancetodrive > 20 or distancetodrive < 14:\n        distancetodrive = 17\n    distancetodrive = distancetodrive + 2\n    driveFor_distance_speed(distancetodrive, 70)\n    turneast()\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 70)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n\n    driveFor_distance_speed(-16 , 75)\n    turneast()\n    wait(3, SECONDS)\n    a = inertial_2.heading(DEGREES) -50\n    turnFor_degree_speed(-a, 30)\n    driveFor_distance_speed(-36, 50)\n\ncurrent_auton_selection = 0\nauton_started = False\ndef menu():\n    global current_auton_selection, auton_started\n    txt = [\"disk far\", \"disk near\", \"block far\", \"block near\", \"far no gyro\", \"original far\"]\n    auton_num = len(txt)\n    brain.screen.set_font(FontType.MONO60)\n    while auton_started == False:\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(2,1)\n        brain.screen.print(txt[current_auton_selection])\n        controller_1.screen.clear_row(1)\n        controller_1.screen.set_cursor(1, 1)\n        controller_1.screen.print(txt[current_auton_selection] + \"        \")\n        if brain.screen.pressing():\n            while brain.screen.pressing():\n                pass\n            current_auton_selection = (current_auton_selection + 1) % auton_num\n            sleep(50)\n\ndef vexcode_auton_function():\n    global current_auton_selection, auton_started\n    MotorGroupLeft.set_stopping(BRAKE)\n    MotorGroupRight.set_stopping(BRAKE)\n    auton_started = True\n    # Start the autonomous task\n    if current_auton_selection == 0:\n        far_disks()\n    elif current_auton_selection == 1:\n        near_disks()\n    elif current_auton_selection == 2:\n        blockFar()\n    elif current_auton_selection == 3:\n        blockNear()\n    elif current_auton_selection == 4:\n        far_no_gyro()\n    elif current_auton_selection == 5:\n        far()\n\ndef ondriver_drivercontrol_1():\n    brain.timer.clear()\n    while brain.timer.time(SECONDS) < 75:\n        wait(5, MSEC)\n    controller_1.rumble(\"---\")\n    onevent_controller_1buttonB_pressed_0()\n\n    while brain.timer.time(SECONDS) < 95:\n        wait(5, MSEC)\n    controller_1.rumble(\"---\")\n\n    while True:\n        a = inertial_2.heading(DEGREES)\n        if (current_auton_selection == 1 or current_auton_selection == 3):\n            if a > 40 + 180 and a < 50 + 180:\n                break\n        else:\n            if a > 40 and a < 50:\n                break\n\n    pneumatics.set(True)\n\ndef vexcode_driver_function():\n    driver_control_task_1 = Thread(ondriver_drivercontrol_1)\n    driver_control_task_2 = Thread(ondriver_drivercontrol_2)\n    MotorGroupLeft.set_stopping(BRAKE)\n    MotorGroupRight.set_stopping(BRAKE)\n    # wait for the driver control period to end\n    while True:\n        # wait 10 milliseconds before checking again\n        wait(10, MSEC)\n\n# system event handlers\ncontroller_1.buttonB.pressed(onevent_controller_1buttonB_pressed_0)\ncontroller_1.buttonL2.pressed(roll)\ncontroller_1.buttonR2.pressed(roll_reverse)\ncontroller_1.buttonL1.pressed(drive_and_roll)\ncontroller_1.buttonRight.pressed(turneast)\ncontroller_1.buttonDown.pressed(turnsouth)\ncontroller_1.buttonLeft.pressed(turnwest)\ncontroller_1.buttonUp.pressed(turnnorth)\n\ncontroller_1.buttonY.pressed(shootString)\n\ncontroller_1.buttonA.pressed(windshieldwiper)\ncontroller_1.buttonX.pressed(test)\n\ncompetition = Competition(vexcode_driver_function, vexcode_auton_function)\n\nwhen_started1()\nmenu()\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}