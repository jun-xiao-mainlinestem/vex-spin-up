{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\nleftmotor1 = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nleftmotor2 = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)\nleftmotor3 = Motor(Ports.PORT12, GearSetting.RATIO_18_1, True)\nMotorGroupLeft = MotorGroup(leftmotor1, leftmotor2, leftmotor3)\nrightmotor1 = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nrightmotor2 = Motor(Ports.PORT19, GearSetting.RATIO_18_1, False)\nrightmotor3 = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nMotorGroupRight = MotorGroup(rightmotor1, rightmotor2, rightmotor3)\nroller = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\npneumatics = DigitalOut(brain.three_wire_port.a)\ninertial_2 = Inertial(Ports.PORT10)\ndistance_2 = Distance(Ports.PORT9)\ncontroller_1 = Controller(PRIMARY)\n\ndrivetrainStop = False\n\nROLL_ANGLE = 120\nROLL_ANGLE_DOUBLE = 200\nROLL_DISTANCE = 4.0\nWALL_DISTANCE = 32\n\ndef when_started1():\n    pneumatics.set(False)\n    roller.set_timeout(2, SECONDS)\n    brain.screen.print(\"Calibrating!\")\n    inertial_2.calibrate()\n    while inertial_2.is_calibrating():\n        sleep(50)\n    controller_1.rumble(\"---\")\n    inertial_2.set_heading(0, DEGREES)\n\nwhen_started1()\n\ndef driveFor_distance_speed(\n    driveFor_distance_speed__distance, driveFor_distance_speed__speed\n):\n    MotorGroupLeft.set_velocity(driveFor_distance_speed__speed, PERCENT)\n    MotorGroupRight.set_velocity(driveFor_distance_speed__speed, PERCENT)\n    d = driveFor_distance_speed__distance / 10.2101675\n    MotorGroupLeft.spin_for(FORWARD, -d, TURNS, wait=False)\n    MotorGroupRight.spin_for(FORWARD, -d, TURNS, wait=True)\n\ndef turnFor_degree_speed(turnFor_degree_speed__degree, turnFor_degree_speed__speed):\n    MotorGroupLeft.set_velocity(turnFor_degree_speed__speed, PERCENT)\n    MotorGroupRight.set_velocity(turnFor_degree_speed__speed, PERCENT)\n    d = turnFor_degree_speed__degree / 0.27\n    MotorGroupLeft.spin_for(REVERSE, d, DEGREES, wait=False)\n    MotorGroupRight.spin_for(REVERSE, (d * -1), DEGREES, wait=True)\n\ndef turnnorth():\n    if inertial_2.heading(DEGREES) <= 180:\n        turnFor_degree_speed(-inertial_2.heading(DEGREES), 80)\n    else:\n        turnFor_degree_speed(360 - inertial_2.heading(DEGREES), 80)\n\ndef turnsouth():\n    turnFor_degree_speed(180 - inertial_2.heading(DEGREES), 80)\n\n\ndef turneast():\n    if inertial_2.heading(DEGREES) > 270:\n        turnFor_degree_speed(360 + 90 - inertial_2.heading(DEGREES), 80)\n    else:\n        turnFor_degree_speed(90 - inertial_2.heading(DEGREES), 80)\n\ndef turnwest():\n    if inertial_2.heading(DEGREES) > 90:\n        turnFor_degree_speed(270 - inertial_2.heading(DEGREES), 80)\n    else:\n        turnFor_degree_speed(-(inertial_2.heading(DEGREES) + 90), 80)\n\ndef ondriver_drivercontrol_2():\n    global drivetrainStop\n    while True:\n        straight = -controller_1.axis3.position()\n        turn = controller_1.axis1.position() / -2\n        if straight == 0 and turn == 0:\n            if drivetrainStop:\n                MotorGroupLeft.stop()\n                MotorGroupRight.stop()\n                drivetrainStop = False\n        else:\n            MotorGroupLeft.set_velocity((straight + turn), PERCENT)\n            MotorGroupRight.set_velocity((straight - turn), PERCENT)\n            MotorGroupLeft.spin(FORWARD)\n            MotorGroupRight.spin(FORWARD)\n            drivetrainStop = True\n        wait(5, MSEC)\n\ndef ondriver_drivercontrol_1():\n    brain.timer.clear()\n    while brain.timer.time(SECONDS) < 75:\n        wait(5, MSEC)\n    controller_1.rumble(\"---\")\n\n    while brain.timer.time(SECONDS) < 95:\n        wait(5, MSEC)\n    controller_1.rumble(\"---\")\n\n    while True:\n        a = inertial_2.heading(DEGREES)\n        if a > 40 and a < 50:\n            break\n\n    pneumatics.set(True)\n\ndef onevent_controller_1buttonB_pressed_0():\n    MotorGroupLeft.set_stopping(HOLD)\n    MotorGroupLeft.stop()\n    MotorGroupRight.set_stopping(HOLD)\n    MotorGroupRight.stop()\n\ndef roll():\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(FORWARD, ROLL_ANGLE_DOUBLE, DEGREES, wait=True)\n\ndef roll_reverse():\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE_DOUBLE, DEGREES, wait=True)\n\ndef drive_and_roll():\n    a = inertial_2.heading(DEGREES)\n    quad = 0\n    if a <= 45 or a > 360 - 45:\n        quad = 1\n    if a > 45 and a <= 90 + 45:\n        quad = 2\n    if a > 90 + 45 and a <= 180 + 45:\n        quad = 3\n    if a > 180 + 45 and a < 360 - 45:\n        quad = 4\n    \n    if quad == 1:\n        turnnorth()\n    if quad == 2:\n        turneast()\n    if quad == 3:\n        turnsouth()\n    if quad == 4:\n        turnwest()\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 75)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(FORWARD, ROLL_ANGLE_DOUBLE, DEGREES, wait=True)\n    driveFor_distance_speed(-1, 75)\n\ndef onauton_autonomous_0():\n    distancetodrive = distance_2.object_distance(INCHES) - WALL_DISTANCE\n    if distancetodrive > 20 or distancetodrive < 14:\n        distancetodrive = 17\n    driveFor_distance_speed(distancetodrive, 40)\n    turnFor_degree_speed(90, 50)\n    distancetodrive = distance_2.object_distance(INCHES) - ROLL_DISTANCE\n    driveFor_distance_speed(distancetodrive, 50)\n    roller.set_velocity(100, PERCENT)\n    roller.spin_for(REVERSE, ROLL_ANGLE, DEGREES, wait=True)\n    driveFor_distance_speed(-4.5, 30)\n    turnFor_degree_speed(-90, 50)\n    driveFor_distance_speed(-60, 30)\n\n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    auton_task_0 = Thread(onauton_autonomous_0)\n    # wait for the driver control period to end\n    while competition.is_autonomous() and competition.is_enabled():\n        # wait 10 milliseconds before checking again\n        wait(10, MSEC)\n    # Stop the autonomous control tasks\n    auton_task_0.stop()\n\n\ndef vexcode_driver_function():\n    driver_control_task_1 = Thread(ondriver_drivercontrol_1)\n    driver_control_task_2 = Thread(ondriver_drivercontrol_2)\n\n    # wait for the driver control period to end\n    while True:\n        # wait 10 milliseconds before checking again\n        wait(10, MSEC)\n    # Stop the driver control tasks\n    driver_control_task_1.stop()\n    driver_control_task_2.stop()\n\n# register the competition functions\ncompetition = Competition(vexcode_driver_function, vexcode_auton_function)\n\n# system event handlers\ncontroller_1.buttonB.pressed(onevent_controller_1buttonB_pressed_0)\ncontroller_1.buttonL2.pressed(roll)\ncontroller_1.buttonR2.pressed(roll_reverse)\ncontroller_1.buttonL1.pressed(drive_and_roll)\ncontroller_1.buttonRight.pressed(turneast)\ncontroller_1.buttonDown.pressed(turnsouth)\ncontroller_1.buttonLeft.pressed(turnwest)\ncontroller_1.buttonUp.pressed(turnnorth)\n\n# controller_1.buttonX.pressed(test)\n\n# add 15ms delay to make sure events are registered correctly.\nwait(15, MSEC)\n#The end - by steve","textLanguage":"python","rconfig":[],"slot":1,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}